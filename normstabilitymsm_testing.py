import louvainLNL
import louvainLCL
import numpy as np
import numpy.linalg as LA
import scipy 
import scipy.sparse
import scipy.spatial.distance as ssd
#import matplotlib.pyplot as plt
import csv
import pandas as pd

""" Currently written without a top loop for the timesteps as current plan is to use 
a single timestep that matches the tau value for the tICA step"""


def full_stability(K, tau, louvain_runs = 50, precision=1e-9):
    """
    K:  transition rate matrix generated by MSMBuilder
    tau: time parameter
    """
    nnodes = K.shape[0]
    
    Dout = np.diag(np.diag(K))
    
    M = np.eye() - np.linalg.inv(Dout).dot(K) #need to check i --> j is right way round

    u,v = np.linalg.eig(M.T) #must be M_transpose if originally defined as M_ij : i --> j

    lambda_ = np.max(u)
    pi_norm = v[:, u == np.max(u)] #extract column corresponding to eigenvalue = 1
    pi_norm = np.abs(pi_norm) #make sure all values are positive

    pi = pi_norm/np.sum(pi_norm)
    
    solution = np.diag(pi).dot(scipy.linalg.expm(tau*K))

    #symmetrize
    solution = (solution+solution.T)/2

    #prune weights that are too small according to precision parameter
    solution = (np.max(solution)*precision)*np.round(solution/((np.max(solution)*precision)))
    graph = find(solution)


    louvain_ensemble = []
    stability_partition_list = []
    number_of_comms_partition_list = []

    #stability calculation
    for i in range(louvain_runs):
        (stability, number_of_comms, community_id) = louvainLNL.stability(graph, 1, precision)
        
        louvain_ensemble.append(community_id)
        stability_partition_list.append(stability)
        number_of_comms_partition_list.append(number_of_comms)
        

    stability = max(stability_partition_list)
    index = stability_partition_list.index(max(stability_partition_list))
    number_of_comms = number_of_comms_partition_list[index]
    community_id = louvain_ensemble[index]

    if calcVI:
        VI = varinfo(louvain_ensemble)  # Added here
        return (stability, number_of_comms, community_id, VI) #will also need to return louvain ensemble
    
    else:
        VI = [] #seems a bit hacky, find a way to return different numbers of variables 
        return (stability, number_of_comms, community_id, VI)



def linear_stability(K, tau, louvain_runs = 50, precision=1e-9):
    """MSM will output M directly so probably no need for this """

    # nnodes = K.shape[0]
    
    # Dout = np.diag(np.diag(K))
    
    # M = np.eye(nnodes) - np.linalg.inv(Dout).dot(K)

    u,v = np.linalg.eig(M.T) #must be M_transpose if originally defined as M_ij : i --> j

    lambda_ = np.max(u)
    pi_norm = v[:, u == np.max(u)] #extract column corresponding to eigenvalue = 1
    pi_norm = np.abs(statdist) #make sure all values are positive

    pi = pi_norm/np.sum(pi_norm)

    solution = (np.diag(pi)).dot(M)
    solution = (solution + solution.T)/2 #need to check why we do this

    graph = find(solution)

    louvain_ensemble = []
    stability_partition_list = []
    number_of_comms_partition_list = []

    #stability calculation
    for i in range(louvain_runs):
        (stability, number_of_comms, community_id) = louvainLNL.stability(graph, tau, precision)
        louvain_ensemble.append(community_id)
        stability_partition_list.append(stability)
        number_of_comms_partition_list.append(number_of_comms)
        if i+1%10 == 0:
            print('Step ' + str(i) + ' of ' + str(louvain_runs) + ' completed.')
        

    stability = max(stability_partition_list)
    index = stability_partition_list.index(max(stability_partition_list))
    number_of_comms = number_of_comms_partition_list[index]
    community_id = louvain_ensemble[index]
    print ('Done ...')

    if calcVI:
        VI = varinfo(louvain_ensemble)  # Added here
        return (stability, number_of_comms, community_id, VI) #will also need to return louvain ensemble
    
    else:
        VI = [] #seems a bit hacky, find a way to return different numbers of variables 
        return (stability, number_of_comms, community_id, VI)



def varinfo(louvain_ensemble):

    louvain_ensemble = np.array(louvain_ensemble) #convert to numpy array

    number_of_partitions = louvain_ensemble.shape[0]
    n = louvain_ensemble.shape[1]
    VI_mat = np.zeros(number_of_partitions)
    VI = 0


    # If all the partitions are identifcal, VI = 0 and there is no need to do the
    # rest of the calculations which are computationally expensive

    if np.all( louvain_ensemble == np.tile(louvain_ensemble[0,:], (number_of_partitions, 1))):
        return 0 # np.zeros((number_of_partitions, number_of_partitions))) - this refers to VI matrix

    # select only partitions that are different
    # need to copy this into new array to stop numpy converting tuples to arrays
    # otherwise 'np.unique' flattens result into single array rather than returning
    # unique rows
    louvain_ensemble = [tuple(row) for row in louvain_ensemble]
    temp_louvain_ensemble = np.empty((number_of_partitions,), dtype=object)
    # enumerate doesn't work here, creates arrays
    for i in range(len(louvain_ensemble)):
        temp_louvain_ensemble[i] = louvain_ensemble[i]

    (louvain_ensemble, indices)  = np.unique(temp_louvain_ensemble, return_inverse = True)
    number_of_partitions = len(louvain_ensemble)
    VI_mat = np.zeros((number_of_partitions, number_of_partitions))

    VI_tot = 0
    nodes = np.linspace(0,n-1,n)
    ones = np.ones(n)

    # need to look into parallelizing loops in numpy
    for i in range(number_of_partitions):
        A_1 = scipy.sparse.csr_matrix((ones , (louvain_ensemble[i], nodes)))
        n_1_all = np.sum(A_1.toarray(), axis=1)
        
        for j in range(i):
            A_2 = scipy.sparse.csr_matrix((ones,(nodes, louvain_ensemble[j])))
            n_2_all = np.sum(A_2.toarray(), axis=0)#check
            n_12_all = np.dot(A_1, A_2)

            (rows, cols, n_12) = find(n_12_all.toarray())

            n_1 = n_1_all[np.array(rows).astype(int)]
            n_2 = n_2_all[np.array(cols).astype(int)]

            VI = np.sum(n_12*np.log((n_12**2)/(n_1 * n_2))) # all element-wise operations
            VI = -1/(n*np.log(n))*VI
            VI_mat[i,j] = VI
            VI_tot = VI_tot+VI
        
    
    VI_mat_full = np.zeros((number_of_partitions, len(indices)))

    for i in range(number_of_partitions):
        VI_mat_full[i] = VI_mat[i, np.array(indices)]
    
    VI_mat_full = VI_mat_full[np.array(indices)]

    VI_mat = VI_mat_full + np.transpose(VI_mat_full)

    VI = np.mean(ssd.squareform(VI_mat))

    return VI # decide on VI_mat









# helper function - replicates Matlab's find function.  Takes ndarray as argument.
def find(matrix):

    unweighted_partition_list = list(zip(np.where(matrix > 0))) #gives [row, col] without values

    edge_partition_list = np.where(matrix > 0)
    partition_list_of_indices = list(zip(edge_partition_list[0], edge_partition_list[1])) #i.e. [(0, 1), (1, 0), (1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]

    values = [matrix[element[0]][element[1]] for element in partition_list_of_indices] #extracts weighting values using indices above

    graph = np.array([unweighted_partition_list[0][0], unweighted_partition_list[1][0], values], dtype=np.float64) #bit ugly, should fix

    return graph



"""Looping though timesteps """

def calculate_linear_stability(adjacency, time_array, louvain_runs=100, precision=1e-9, calcVI=True):
    """ 
    Need adjacency to be a dense array here
    """      


    timesteps = [element[0] for element in enumerate(time_array)]

    solution = (np.diag(pi)).dot(M)
    solution = (solution + solution.T)/2 #need to check why we do this

    graph = find(solution)

    stability_array = []
    number_of_comms_array = []
    community_id_array = []
    VI_array = []

    for i, time in enumerate(time_array): #time is an array of times

        (stability, number_of_comms, community_id, VI) = _linear_stability(graph, time, louvain_runs, precision, calcVI)

        stability_array.append(stability)
        number_of_comms_array.append(number_of_comms)
        community_id_array.append(community_id)
        VI_array.append(VI)

        print ('Timestep ' + str(i+1) + ' of ' + str(len(time_array)) + ' completed.')

    stability_results_frame = pd.DataFrame(
        {
            'Markov time' : time_array,
            'stability' : stability_array,
            'number_of_communities' : number_of_comms_array,
            'community_id' : community_id_array,
            'VI' : VI_array
        },
        index=timesteps,
    )

    return stability_results_frame            


def linear_stability(graph, time, louvain_runs, precision, calcVI):

   

    louvain_ensemble = []
    stability_partition_list = []
    number_of_comms_partition_list = []

    #stability calculation
    for i in range(louvain_runs):
        (stability, number_of_comms, community_id) = louvainLNL.stability(graph, time, precision)
        louvain_ensemble.append(community_id)
        stability_partition_list.append(stability)
        number_of_comms_partition_list.append(number_of_comms)
       

    if calcVI:
        VI = varinfo(louvain_ensemble) # Added here
        return (stability, number_of_comms, community_id, VI)

    else:
        VI = [] #seems a bit hacky, find a way to return different numbers of variables 
        return (stability, number_of_comms, community_id, VI)











#basic plot function
def plot_stability(timesteps, number_of_communities, stability, VI):

    x = np.array(timesteps)
    y1 = np.array(number_of_communities)
    y2 = np.array(stability)
    y3 = np.array(VI)

    ax1 = plt.subplot(211)
    ax1.plot(x, y1, 'r')
    ax1.set_ylabel('Number of communities')

    ax2 = ax1.twinx()
    ax2.plot(x, y2, 'g')
    ax2.set_ylabel('Stability')

    ax3 = plt.subplot(212)
    ax3.plot(x, y3, 'b')
    ax3.set_xlabel('Markov time (s)')
    ax3.set_ylabel('Variation of Information')

    plt.show()

"""    




